- 문제: [요세푸스 문제](https://github.com/kciter/coding-interview-js)
- 풀이 참고: [kciter/coding-interview-js](https://github.com/kciter/coding-interview-js/blob/main/solution/14.js)
- 상태: 🟡 비효율
- 복습필요: Y

## 1. 문제 설명

탁자에 앉은 n명의 사람이 있을 때, 첫 번째 사람을 기준으로 k번째 사람을 없앴을 때 최후에 남는 1명의 번호를 구해라.

## 2. 내 접근 방식

큐 카테고리에 있는 문제라 큐를 사용하는 것일 텐데 떠오르지 않아서 단순 구현으로 접근했다.
n 길이 만큼의 배열을 만들고 cursor를 0으로 초기화한 다음,
배열의 길이가 1 이상일 때까지 루프를 돌면서
(cursor + k - 1) % 배열의 길이인 인덱스를 구하고 splice로 해당 인덱스 값을 날리는 방식으로 접근했다.

## 3. 틀린 이유

틀렸다기 보다는 좀 비효율적인 풀이에 가깝다.
그리고 책에서 큐 개념을 설명하고 큐 예시문제로 이 문제를 낸 건데 단순 구현으로 푼 것이 아쉽다고 생각했다.

## 4. 올바른 접근 및 풀이

(책 풀이 참고함)
핵심 컨셉은 실제로 인덱스에 해당하는 곳의 값을 제거하고 하나씩 이동하는 동작을 하는 것이 아니라,
큐를 활용해 값을 팝하고 푸시하면서 삭제할 값이 제일 앞으로 오게끔 만드는 것이다.

만약 (앞) 1 2 3 4 5 (뒤) 이고 3번째를 없앤다고 했을 때
2번째까지 팝하고 푸시 반복하면 (앞) 3 4 5 1 2 (뒤) 가 되고
팝하면 3번째 값인 3이 없어진다. (앞) 4 5 1 2 (뒤)

이렇게 되면 팝하고 푸시를 k-1번하는 것을 n번 반복하게 되어 시간 복잡도는 O(n \* k)가 된다.

## 5. 배운 점

스택 부분 문제 풀 때도 느꼈지만 배열 조작으로 푸는 것 외에 자료구조나 알고리즘을 활용할 방법을 좀 더 고민해야겠다고 느꼈다. 대부분 배열 조작 (삽입/삭제)를 직접하지 않아도 풀 수 있다.
